# Аутентификация 3. Kerberos
## WTF is Kerberos
В предыдущей части, когда мы разбирали LDAP мы частично затронули вопросы безопасности этого протокола и выяснили, что используя LDAP bind мы с вами далеко не уедем. Но что же делать, если все-таки хочется централизованно управлять пользователями и их правами, с одной стороны, и иметь возможность надежной и безопасной аутентификации, с другой? Вот тут на помощь и приходит Kerberos.
> Disclamer: Я тут постараюсь описать все максимально упрощенно, не вдаваясь в подробности и прошу простить меня за некоторые неточности в описании реализации (например, я умышленно опустил всю криптографию). Цель этого intro -- понять Kerberos настолько, что бы иметь возможность настроить клиентское приложение для работы с ним. Настройку KDC и нюансы протокола мы тут рассматривать не будем. Тем не менее, для углубления понимания можно почитать Kerberos RFC [4120](https://datatracker.ietf.org/doc/html/rfc4120) и полистать [сайт консорциума](https://kerberos.org/)

Главным предположением в основе Kerberos протокола является работа в недоверенной сети, т.е. никакие конфиденциальные данные не могут быть переданы никому в открытом виде. Что бы как-то выжить в такой недружелюбной среде, нам необходимо выделить некоего хранителя аутентификационной информации и доверять (и защищать) только ему. Этому хранителю мы будем передавать нашу аутентификационную информацию(давать логин и пароль), в ответ получая некие ключи, с помощью которых мы и будем подтверждать себя в диалоге с другими системами. Т.к. наш хранитель выдает ключи, то и называть мы его будем Центром Выдачи Ключей (KDC). 
Что же находится внутри ключа? Внутри у нас лежит во-первых владелец ключа(Client Principal), во вторых приложение, которому будет ключ предъявлен (Service Principal), в третьих временную метку момента выпуска ключа и срок действия ключа и, наконец, секретный ключ сессии, который знает только приложение и (теперь) клиент. Теперь у нас есть некий тикет, который мы можем отдать приложению, что бы оно убедилось, что мы те, за кого себя выдаем
На самом деле, все немного сложнее и в KDC мы ходим не один раз, а 2:
```puml
participant Client as c
participant KDC as k
participant Application as a

c ->  k: AS_REQ (отправляем аутентификационные данные)
k --> c: AS_REP (получаем TGT)
c ->  k: TGS_REQ (отправляем TGT и сервис, к которому хотим пойти)
k --> c: TGS_REP (получаем тикет)
c ->  a: AP_REQ (идем в сервис)
a --> c: AP_REP
```

Зачем же 2 раза ходить в KDC? Почему нельзя сразу попросить тикет для нужного приложения? На самом деле, можно и так (например используя в kinit флажок -s), но, в этом случае, тикет будет получен для конкретного приложения и SSO (обсудим его чуть дальше) работать не будет. В базовом же сценарии, мы сначала приходим в KDC и получаем TGT (ticket granting ticket), а уже TGT меняем на финальный тикет, с которым идем в приложение.
Помимо этого, внимательный читатель заметит, что если мы передаем в KDC логин и пароль(или другие креды) в нешифрованном AS_REQ, то смысл всей этой сложной машинерии совершенно теряется, т.к. даже школьник с wireshark'ом сможет увести ваш пароль и Kerberos становится ничем не лучше Basic Auth. На самом деле, это действительно так, и Kerberos действует обратным образом: в AS_REQ KDC принимает только Principal пользователя, а вот его паролем он шифрует TGT в AS_REP
На всякий случай, приведу тут словарик Kerberos-терминов, которые наверняка вам встретятся при работе с этим чудом техники:

- Realm -- некий керберосный теннант. Чаще всего соответсвует корпоративному домену но в UPPER CASE. В наших примерах это EXAMPLE.ORG
- Principal -- аутентифицируемое лицо. Принципалы бывают разные: бывает Service Principal -- это некое приложение, которое хочет аутентифицироваться само и может принимать оказывать какой-то сервис User Principal'ам. User Principal'ы -- это уже конечные пользователи. При этом и у user'ов и у service'ов есть kerberos principal(в случае MIT Kerberos это krbPrincipalName) -- это, в свою очередь просто некий атрибут(для простоты можно считать его керберосным username'ом)
- SPN -- Service Principal Name. Это как раз kerberos principal у Service Principal'а. Обычно формируется в виде протокол/урл_сервиса@реалм. Для нашего кейклока это будет HTTP/keycloak@EXAMPLE.ORG(потому что это веб-сервис, который висит на домене keycloak и находится в реалме EXAMPLE.ORG). Если бы мы хотели аутентифицировать(и аутентифицироваться в) почтовый сервис, то у нас было бы что-то типа SMTP/postfix.example.org@EXAMPLE.ORG
- UPN -- вообще это стандартный LDAP атрибут(User Principal Name) в Microsoft ActiveDirectory, который мы немного затронули в предыдущей главе про LDAP, но тут еще раз остановимся на нем с важным уточнением: в ActiveDirectory обычно UPN и KerberosPrincipal пользователей одинаковые, но _это не обязательно_. Я лично видел инсталяцию, где UPN и Kerberos Principal пользоватлей отличались
- Keytab -- как мы разобрались выше, принципалы бывают User, а бывают Service. В процессе аутентификации на этапе отправки AS_REQ/AS_REP кожанный UserPrincipalName может отправить свои креденшеналы, а что же делать железному Service Principal'у? Вот для него как раз и изобрели keytab (от key table -- таблица ключей). На самом деле в .keytab-файле просто лежит "пароль" (на самом деле хитро-шифрованный ключ) Service Principal'а с помощью которого он аутенцифицируется в KDC.
- KVNO -- версия секретного ключа принципала. Дело в том, что при смене пароля принципала, для него генерируется новый секретный ключ и что бы тикеты, которые были подписаны старым ключем протухли, используется KVNO. Фактически это просто номер версии, который инкрементально растет при каждой смене пароля
- KDC --  key distribution center. Фактически -- Kerberos-сервер
- AS -- подсистема KDC, обрабатывающая AS_ запросы
- TGS -- подсистема KDC, обрабатывающая TGS_ запросы
- TGT -- tickets granting ticket. Тикет тикетов. Именно его мы можем обменять у KDC на конечный тикет для конечного приложения.
- krbtgt - специальный сервис Kerberos'а, который выдает TGT(все TGT у нас шифрованы ключем принципала krbtgt/EXAMPLE.ORG@EXAMPLE.ORG)
  
## Магия SSO
Это все замечательно, но самый главный фокус который дает Kerberos, это даже не безопасная аутентификация, а то, что с Kerberos'ом мы можем войти в любую систему, не заставляя пользователя постоянно вводить логин и пароль (т.н. механика Single-Sign-On или SSO).
Все это получается благодаря тому, что у нас вместо обычного пароля есть тикет и мы можем абсолютно безопасно предъявлять его в KDC при входе в любую систему, тем самым, автоматически авторизовываясь в этой системе. Системе остается всего-лишь попросить у пользователя его тикет, для чего мы будем использовать механизм SPNEGO, но не просто так, а обернутый в GSSAPI. Давайте разбираться дальше.

## SPNEGO
## GSSAPI
> для дальнейших упражнений можно взять [мой набор docker-compose песочниц](https://github.com/ondator/sandboxes) и попользоваться компоузом keycloak/keycloak-postgres-dc.yml

## Настройка KDC
> этот шаг мы делаем самостоятельно только на нашем тестовом стенде. В бою, для вас все выполнит администратор контроллера домена.
В этот момент нам понадобится контейнер kdc. Проваливаемся в него и делаем следующее:
1. Создаем принципала для нашего кейклока 
   ```sh
   $ kadmin.local
   $ addprinc -x dn=cn=keycloak2,ou=tuz,dc=example,dc=org HTTP/keycloak2
   ```
> я выбрал 2й, но вы можете аналогично создать и для 1го
2. Добавляем kerberos-атрибуты (делаем пользователя принципалом) для Alice
   ```sh
   $ kadmin.local
   $ addprinc -x dn=cn=Alice,ou=people,dc=example,dc=org alice
   ```
3. в контейнере _keycloak2_ генерим кейтаб-файл для нашего сервиса
   ```sh
   $ kadmin -p HTTP/keycloak2@EXAMPLE.ORG
   $ ktadd -k /tmp/kc2.keytab HTTP/keycloak2
   ```

в результате всех манипуляций, в контейнере keycloak2 должен появиться файл /tmp/kc2.keytab и при вызове `KRB5_TRACE=/dev/stdout kinit -k -t /tmp/kc2.keytab HTTP/keycloak2@EXAMPLE.ORG`
не должно вывалиться ошибок, а если после еще и вызвать `klist -l`, то должно появиться что-то вроде
```sh
Principal name                 Cache name
--------------                 ----------
HTTP/keycloak2@EXAMPLE.ORG          FILE:/tmp/krb5cc_1001
```

## Настройка Keycloak
1. открываем 88 порт от нашего кейклока до KDC
2. получаем SPN и кейтаб (см предыдущий пункт)
3. создаем krb5.conf в /etc 
```ini
[libdefaults]
 default_realm = EXAMPLE.ORG

[realms]
 EXAMPLE.COM = {
  kdc = DC.EXAMPLE.ORG
  default_domain = EXAMPLE.ORG
 }
```
Если мы не знаем адрес kdc, то можно попробовать посмотреть nslookup'ом:
`nslookup -type=any _kerberos._tcp.EXAMPLE.ORG`

4. на всякий случай стоит сделать `KRB5_TRACE=/dev/stdout kinit -k -t /tmp/kc2.keytab HTTP/keycloak2@EXAMPLE.ORG`
5. вы великолепны

> если используете keycloak-postgres-dc.yml из моего компоуза то пп 1 и 3 можно пропустить

## Дебаг

не работать может потому что
1. вы криворукий дебил
2. админ контроллера домена криворукий дебил

- что бы убедиться, что мы не верблюды, стоит получить kerberos tiket и посмотреть на него:
1. делаем `KRB5_TRACE=/dev/stdout kinit -k -t /tmp/kc2.keytab HTTP/keycloak2@EXAMPLE.ORG`
2. делаем `klist -l`

- что бы убедиться, что админ АД не верблюд мы
1. проверим групповые политики в __используемом пользователем__ браузере
- в хроме жмем chrome://policy и ищем AuthNegotiateDelegateWhitelist и AuthServerWhitelist. Там долны быть домены нашего приложения
- в яндексе жмем browser://policy и ищем AuthNegotiateDelegateAllowlist и AuthServerAllowlist. Там долны быть домены нашего приложения
2. если политики не прописаны, то есть способ запустить браузер с флагами и убедиться, что мудак действительно одмен:
`"C:\Program Files\Google\Chrome\Application\chrome.exe" --auth-server-whitelist="*.example.com,example.com" --auth-negotiate-delegate-whitelist="*.example.com,example.com"`
3. в конце-концов можно поснифать spnego-токены(просто через F12/network их не видно): chrome://net-export/

- еще стоит

1. Включить ползунок парольной аутентификации через керберос. Если проблема именно со spnego, то аутентификация по паролю будет работать, если проблема с керберосом, то посыпятся логи
2. проверить kerberos principal. Внезапно он может оказаться отличным от UserPrincipalName в ActiveDirectory. Симптомы -- ошибка вида при включенной галке парольной аутентификации через керберос
```
>>>KRBError:
         sTime is Mon Oct 07 17:36:33 UTC 2024 1728322593000
         suSec is 644455
         error code is 68
         error Message is null
         sname is krbtgt/FSKEES.RU@FSKEES.RU
         msgType is 30
                [Krb5LoginModule] authentication failed
```

> N.B. логика создания kerberos принципала в кейклоке следующая: при импорте пользователя берется атрибут указанный в поле Kerberos principal attribute и записывается в readOnly атрибут пользователя KERBEROS_PRINCIPAL. При аутентификации значение достается из KERBEROS_PRINCIPAL, и если оно с доменным суффиксом, то отдается в KDC как есть, если без суффикса, то суффикс приделывается исходя из kerberos realm'а. Т.е. если UPN с некорректным суффиксом, а sAMAccountName корректный, то sAMAccountName в Kerberos principal attribute решит проблему. При этом, в версии ниже 22.0.5 зачем-то сделана странная проверка на доменный суффикс, и UPN, если суффикс отличается от реалма даже не будет отправлен в KDC(процесс сразу свалится с ошибкой). С 22.0.5 это поведение убрали, но почему-то sAMAccountName в Kerberos principal attribute ломает импорт пользователей. Кажется, что единственное рабочее -- не заполнять Kerberos principal attribute вообще, в этом случае кейклок положит в KERBEROS_PRINCIPAL username
3. Проверить криптоалгоритмы в krb5.conf. Вероятно надо включить allow_weak_crypto = true и что-то дописать в permitted_enctypes. Симптомы -- ошибка вида 
   ```
   2024-06-06 07:54:31,547 WARN  [org.keycloak.federation.kerberos.impl.SPNEGOAuthenticator] (executor-thread-185) SPNEGO login failed: java.security.PrivilegedActionException: GSSException: Failure unspecified at GSS-API level (Mechanism level: Invalid argument (400) - Cannot find key of appropriate type to decrypt AP-REQ - RC4 with HMAC)
   ```

   в этом случае krb5.conf должен выглядеть как-то так:
   ```ini
   [libdefaults]
   default_realm = EXAMPLE.ORG
   allow_weak_crypto = true
   # permitted_enctypes = rc4-hmac arcfour-hmac arcfour-hmac-md5
   # default_tkt_enctypes = rc4-hmac arcfour-hmac arcfour-hmac-md5
   # default_tgs_enctypes = rc4-hmac arcfour-hmac arcfour-hmac-md5
   default_tkt_enctypes = aes256-cts-hmac-sha1-96 aes128-cts-hmac-sha1-96 rc4-hmac
   default_tgs_enctypes = aes256-cts-hmac-sha1-96 aes128-cts-hmac-sha1-96 rc4-hmac

   [realms]
   EXAMPLE.COM = {
   kdc = DC.EXAMPLE.ORG
   default_domain = EXAMPLE.ORG
   }
   ```