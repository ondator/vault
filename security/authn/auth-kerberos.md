# Аутентификация 3. Kerberos
## WTF is Kerberos
В предыдущей части, когда мы разбирали LDAP мы частично затронули вопросы безопасности этого протокола и выяснили, что используя LDAP bind мы с вами далеко не уедем. Но что же делать, если все-таки хочется централизованно управлять пользователями и их правами, с одной стороны, и иметь возможность надежной и безопасной аутентификации, с другой? Вот тут на помощь и приходит Kerberos.
> Disclamer: Я тут постараюсь описать все максимально упрощенно, не вдаваясь в подробности и прошу простить меня за некоторые неточности в описании реализации (например, я умышленно опустил всю криптографию). Цель этого intro -- понять Kerberos настолько, что бы иметь возможность настроить клиентское приложение для работы с ним. Настройку KDC и нюансы протокола мы тут рассматривать не будем. Тем не менее, для углубления понимания можно почитать Kerberos RFC [4120](https://datatracker.ietf.org/doc/html/rfc4120) и полистать [сайт консорциума](https://kerberos.org/)

Главным предположением в основе Kerberos протокола является работа в недоверенной сети, т.е. никакие конфиденциальные данные не могут быть переданы никому в открытом виде. Что бы как-то выжить в такой недружелюбной среде, нам необходимо выделить некоего хранителя аутентификационной информации и доверять (и защищать) только ему. Этому хранителю мы будем передавать нашу аутентификационную информацию(давать логин и пароль), в ответ получая некие ключи, с помощью которых мы и будем подтверждать себя в диалоге с другими системами. Т.к. наш хранитель выдает ключи, то и называть мы его будем Центром Выдачи Ключей (KDC). 
Что же находится внутри ключа? Внутри у нас лежит во-первых владелец ключа(Client Principal), во вторых приложение, которому будет ключ предъявлен (Service Principal), в третьих временную метку момента выпуска ключа и срок действия ключа и, наконец, секретный ключ сессии, который знает только приложение и (теперь) клиент. Теперь у нас есть некий тикет, который мы можем отдать приложению, что бы оно убедилось, что мы те, за кого себя выдаем
На самом деле, все немного сложнее и в KDC мы ходим не один раз, а 2:
```puml
participant Client as c
participant KDC as k
participant Application as a

c ->  k: AS_REQ (отправляем аутентификационные данные)
k --> c: AS_REP (получаем TGT)
c ->  k: TGS_REQ (отправляем TGT и сервис, к которому хотим пойти)
k --> c: TGS_REP (получаем тикет)
c ->  a: AP_REQ (идем в сервис)
a --> c: AP_REP
```

Зачем же 2 раза ходить в KDC? Почему нельзя сразу попросить тикет для нужного приложения? На самом деле, можно и так (например используя в kinit флажок -s), но, в этом случае, тикет будет получен для конкретного приложения и SSO (обсудим его чуть дальше) работать не будет. В базовом же сценарии, мы сначала приходим в KDC и получаем TGT (ticket granting ticket), а уже TGT меняем на финальный тикет, с которым идем в приложение.
Помимо этого, внимательный читатель заметит, что если мы передаем в KDC логин и пароль(или другие креды) в нешифрованном AS_REQ, то смысл всей этой сложной машинерии совершенно теряется, т.к. даже школьник с wireshark'ом сможет увести ваш пароль и Kerberos становится ничем не лучше Basic Auth. На самом деле, это действительно так, и Kerberos действует обратным образом: в AS_REQ KDC принимает только Principal пользователя, а вот его паролем(точнее cgtwbfkmysv ключем) он шифрует TGT в AS_REP
Помимо этого, внимательный читатель заметит, что если мы передаем в KDC логин и пароль(или другие креды) в нешифрованном AS_REQ, то смысл всей этой сложной машинерии совершенно теряется, т.к. даже школьник с wireshark'ом сможет увести ваш пароль и Kerberos становится ничем не лучше Basic Auth. На самом деле, это действительно так, и Kerberos действует обратным образом: в AS_REQ KDC принимает только Principal пользователя, а вот его паролем(точнее специальным секретным ключем, получаемым из пароля) он шифрует TGT в AS_REP
На всякий случай, приведу тут словарик Kerberos-терминов, которые наверняка вам встретятся при работе с этим чудом техники:

- Realm -- некий керберосный теннант. Чаще всего соответсвует корпоративному домену но в UPPER CASE. В наших примерах это EXAMPLE.ORG
- Principal -- аутентифицируемое лицо. Принципалы бывают разные: бывает Service Principal -- это некое приложение, которое хочет аутентифицироваться само и может принимать оказывать какой-то сервис User Principal'ам. User Principal'ы -- это уже конечные пользователи. При этом и у user'ов и у service'ов есть kerberos principal(в случае MIT Kerberos это krbPrincipalName) -- это, в свою очередь просто некий атрибут(для простоты можно считать его керберосным username'ом)
- SPN -- Service Principal Name. Это как раз kerberos principal у Service Principal'а. Обычно формируется в виде протокол/урл_сервиса@реалм. Для нашего кейклока это будет HTTP/keycloak@EXAMPLE.ORG(потому что это веб-сервис, который висит на домене keycloak и находится в реалме EXAMPLE.ORG). Если бы мы хотели аутентифицировать(и аутентифицироваться в) почтовый сервис, то у нас было бы что-то типа SMTP/postfix.example.org@EXAMPLE.ORG
- UPN -- вообще это стандартный LDAP атрибут(User Principal Name) в Microsoft ActiveDirectory, который мы немного затронули в предыдущей главе про LDAP, но тут еще раз остановимся на нем с важным уточнением: в ActiveDirectory обычно UPN и KerberosPrincipal пользователей одинаковые, но _это не обязательно_. Я лично видел инсталяцию, где UPN и Kerberos Principal пользоватлей отличались
- Keytab -- как мы разобрались выше, принципалы бывают User, а бывают Service. В процессе аутентификации на этапе отправки AS_REQ/AS_REP кожанный UserPrincipalName может отправить свои креденшеналы, а что же делать железному Service Principal'у? Вот для него как раз и изобрели keytab (от key table -- таблица ключей). На самом деле в .keytab-файле просто лежит "пароль" (на самом деле хитро-шифрованный ключ) Service Principal'а с помощью которого он аутенцифицируется в KDC.
- KVNO -- версия секретного ключа принципала. Дело в том, что при смене пароля принципала, для него генерируется новый секретный ключ и что бы тикеты, которые были подписаны старым ключем протухли, используется KVNO. Фактически это просто номер версии, который инкрементально растет при каждой смене пароля
- KDC --  key distribution center. Фактически -- Kerberos-сервер
- AS -- подсистема KDC, обрабатывающая AS_ запросы
- TGS -- подсистема KDC, обрабатывающая TGS_ запросы
- TGT -- tickets granting ticket. Тикет тикетов. Именно его мы можем обменять у KDC на конечный тикет для конечного приложения.
- krbtgt - специальный сервис Kerberos'а, который выдает TGT(все TGT у нас шифрованы ключем принципала krbtgt/EXAMPLE.ORG@EXAMPLE.ORG)
  
## Магия SSO
Это все замечательно, но самый главный фокус который дает Kerberos, это даже не безопасная аутентификация, а то, что с Kerberos'ом мы можем войти в любую систему, не заставляя пользователя постоянно вводить логин и пароль (т.н. механика Single-Sign-On или SSO).
Все это получается благодаря тому, что у нас вместо обычного пароля есть тикет и мы можем абсолютно безопасно предъявлять его в KDC при входе в любую систему, тем самым, автоматически авторизовываясь в этой системе. Системе остается всего-лишь попросить у пользователя его тикет, для чего мы будем использовать механизм SPNEGO, вокруг GSS-API. Давайте разбираться дальше и начнем с GSS-API

## GSS-API
> GSS-API описано в отдельных [RFC 2743](https://datatracker.ietf.org/doc/html/rfc2743) и [RFC 4121](https://datatracker.ietf.org/doc/html/rfc4121) 

GSS-API (generic security services API) это просто единый интрефейс над различными security протоколами(Kerberos, SASL, NTML и т.д.). Это чем-то похоже на дисковые интерфейсы завернутые в SCSI, только для безопасности. 
## SPNEGO
> SPNEGO описано в отдельном [RFC 4178](https://datatracker.ietf.org/doc/html/rfc4178). Так же будет полезно полистать [RFC 4559](https://datatracker.ietf.org/doc/html/rfc4559), что бы понять как токены просачиваются в систему и оттуда кочуют в браузер

И так, вот у нас есть букет неких секьюрити сервисов обернутых в единый интерфейс GSS-API. Все, чего нам не хватает тут -- это механизма выбора из всего этого многообразия нужного нам механизма. И вот тут-то и появляется SPNEGO. Именно он формирует из этого веера GSS-API живую очередь, где сверху торчит наиболее предпочтительный механизм, а дальше расположены в порядке убывания предпочтительности все остальные. Т.е. если наш компьютер умеет в Kerberos, NTLM и старые добрые логины-пароли, то именно это мы предложим кейклоку, а кейклок уже выберет то, что он поддерживает, причем выберет наиболее нам подходящее. Что бы эта магия отработала наш компьютер(а точнее браузер) должен провести переговоры(Negotiate) с кейклоком. Для этого, кейклок отправляет 401 ответ со специальным заголовоком www-authenticate: Negotiate. Браузер в этот момент добывает керберос тикет через GSS-API для принципала вида HTTP/<url_сервиса>@РЕАЛМ, оборачивает его в форму GSS-API InitialContextToken'а и отправляет кейклоку в заоголовке Authorization: Negotiate <тут_наш_токен>. Если кейклок не смог в керберос, то все начинается по-новой, но в этот раз SPNEGO в браузере пользователя выберет что-то другое(менее предпочтительное) и так будет продолжаться пока браузер пользователя и кейлок не договорятся между собой.

> для дальнейших упражнений можно взять [мой набор docker-compose песочниц](https://github.com/ondator/sandboxes) и попользоваться компоузом keycloak/keycloak-postgres-dc.yml

## Настройка KDC
> этот шаг мы делаем самостоятельно только на нашем тестовом стенде. В бою, для вас все выполнит администратор контроллера домена.

В этот момент нам понадобится контейнер kdc. Проваливаемся в него и делаем следующее:
1. Создаем принципала для нашего кейклока 
   ```sh
   $ kadmin.local
   $ addprinc -x dn=cn=keycloak2,ou=tuz,dc=example,dc=org HTTP/keycloak2
   ```
> я выбрал 2й, но вы можете аналогично создать и для 1го
2. Добавляем kerberos-атрибуты (делаем пользователя принципалом) для Alice
   ```sh
   $ kadmin.local
   $ addprinc -x dn=cn=Alice,ou=people,dc=example,dc=org alice
   ```
3. в контейнере _keycloak2_ генерим кейтаб-файл для нашего сервиса
   ```sh
   $ kadmin -p HTTP/keycloak2@EXAMPLE.ORG
   $ ktadd -k /tmp/kc2.keytab HTTP/keycloak2
   ```

в результате всех манипуляций, в контейнере keycloak2 должен появиться файл /tmp/kc2.keytab и при вызове `KRB5_TRACE=/dev/stdout kinit -k -t /tmp/kc2.keytab HTTP/keycloak2@EXAMPLE.ORG`
не должно вывалиться ошибок, а если после еще и вызвать `klist -l`, то должно появиться что-то вроде
```sh
Principal name                 Cache name
--------------                 ----------
HTTP/keycloak2@EXAMPLE.ORG          FILE:/tmp/krb5cc_1001
```

## Настройка Keycloak
1. открываем 88 порт от нашего кейклока до KDC
2. получаем SPN и кейтаб (см предыдущий пункт)
3. создаем krb5.conf в /etc 
```ini
[libdefaults]
 default_realm = EXAMPLE.ORG

[realms]
 EXAMPLE.COM = {
  kdc = DC.EXAMPLE.ORG
  default_domain = EXAMPLE.ORG
 }
```
Если мы не знаем адрес kdc, то можно попробовать посмотреть nslookup'ом:
`nslookup -type=any _kerberos._tcp.EXAMPLE.ORG`

4. на всякий случай стоит сделать `KRB5_TRACE=/dev/stdout kinit -k -t /tmp/kc2.keytab HTTP/keycloak2@EXAMPLE.ORG`
> если используете keycloak-postgres-dc.yml из моего компоуза то пп 1 и 3 можно пропустить
5. идем в кейклок. дальнейшие шаги зависят от того, хотите ли вы настраивать аутентификацию по LDAP+Kerberos или только по Kerberos. 
6. Если идем вместе с LDAP, то идем в раздел UserFederation и настраиваем федерацию как в предыдущем лонгриде(или берем уже готовую). Теперь, в федерации листаем до секции Kerberos integration, которую мы пропустили в прошлый раз и включаем галочку Allow Kerberos authentication. 
   Если хотим голый Kerberos, то создаем новую федерацию, на этот раз типа Kerberos
7. Заполняем появившиеся поля:
- Kerberos realm -- сюда внезапно вносим наш Kerberos реалм. В нашем случае это EXAMPLE.ORG
- Server principal -- сюда пишем SPN на которого чуть выше выпускали кейтаб (HTTP/keycloak2@EXAMPLE.ORG)
- Key tab -- тут нам надо прописать путь к кейтабу. В нашем случае он упал в /tmp/kc2.keytab, в дикой природе он либо монтируется в контейнер configMap'ом, либо заботливо подкладывается куда-нибудь в /etc, если у вас кейклок живет на systemd
- Kerberos principal attribute -- очень важная настройка, которая появилась не так давно. Она определяет эвристику, по которой кейклок будет сопоставлять LDAP-запись с kerberosPrincipal'ом. Т.е. фактически как кейлоку понять какой пользователь в LDAP'е соответствует какому в Kerberos'е. В случае OpenLDAP'а и MIT/Heimdal Kerberos'а (сюда же относятся FreeIPA, SambaDC и пр.) вам дадут специально обученный LDAP-атрибут(обычно krbprincipalname). В случае Microsoft AD надо быть аккуратным. Обычно сюда можно прописать UserPrincipalName, но, есть не нулевая вероятность, что UserPrincipalName не подойдет и тогда нужно будет либо просить админов AD добавить необходимый атрибут, либо попробовать оставить эту настройку пустой, что бы кейклок попробовал собрать kerberos principal самостоятельно(логику описал чуть ниже в разделе Дебаг)
- Включаем галку Debug, что бы kerberos-подсистема Keycloak сыпала отладочной информацией в логи
- Опционально можно включить галку Use Kerberos for password authentication. Она сильно помогает при отладке
8. Если вы создали федерацию типа Kerberos(без LDAP), то можно еще включить галку Update first login, что бы keycloak что-то высосал из тикета. ИМХО достаточно бесполезная галка, т.к. в тикете практически нет никакой информации.
9. Теперь нам надо включить kerberos аутентификатор. Для этого переходим в раздел Authentication и выбираем flow, который привязан к нашему клиенту (по-умолчанию, это browser), ищем step "Kerberos" и переводим его в состояние "Alternative". Этим легким движением руки мы включили SPNEGO в кейлоке и теперь при попытке аутентификации пользователь будет не просто получать 401, а еще и долгожданный заголовок www-authenticate: Negotiate.
10. Вы великолепны! Если все сделано правильно, то пользователи должны пройти в кейклок используя Kerberos, а пользователи соответствующего домена пройдут еще и бесшовно(используя SPNEGO)

> Если вы сделали федерацию типа LDAP+Kerberos, то для аутентификации по паролю, пользователь должен ввести свой username (то, что указано в поле Username LDAP attribute федерации). Если же федерация типа Kerberos, то пользователь должен ввести свой principal name (alice@EXAMPLE.ORG)

## Дебаг
Для начала, стоит запустить кейклок с расширенными логами кербероса. В bitnami это env'ы 
```
KEYCLOAK_LOG_LEVEL: WARN,...,sun.security.krb5:debug,sun.security.spnego:debug
KEYCLOAK_EXTRA_ARGS: ... -Dsun.security.krb5.debug=true -Dsun.security.spnego.debug=true
```
> в quay.io все то же самое, но енвы называются KC_LOG_LEVEL и KC_EXTRA_ARGS соответственно. Если запускаем jar, то настраиваем в standalone-ha.xml, согласно документации

Вообще, не работать может потому что
1. вы криворукий дибил
2. админ контроллера домена криворукий дибил

- что бы убедиться, что мы не верблюды, стоит получить kerberos tiket и посмотреть на него:
1. делаем `KRB5_TRACE=/dev/stdout kinit -k -t /tmp/kc2.keytab HTTP/keycloak2@EXAMPLE.ORG`
2. делаем `klist -l`

- что бы убедиться, что админ АД не верблюд мы
1. проверим групповые политики в __используемом пользователем__ браузере
- в хроме жмем chrome://policy и ищем AuthNegotiateDelegateWhitelist и AuthServerWhitelist. Там долны быть домены нашего приложения
- в яндексе жмем browser://policy и ищем AuthNegotiateDelegateAllowlist и AuthServerAllowlist. Там долны быть домены нашего приложения
2. если политики не прописаны, то есть способ запустить браузер с флагами и убедиться, что мудак действительно одмен:
`"C:\Program Files\Google\Chrome\Application\chrome.exe" --auth-server-whitelist="*.example.com,example.com" --auth-negotiate-delegate-whitelist="*.example.com,example.com"`
3. в конце-концов можно поснифать spnego-токены(просто через F12/network их не видно): chrome://net-export/

- еще стоит

1. Включить ползунок парольной аутентификации через керберос. Если проблема именно со spnego, то аутентификация по паролю будет работать, если проблема с керберосом, то посыпятся логи
2. проверить kerberos principal. Внезапно он может оказаться отличным от UserPrincipalName в ActiveDirectory. Симптомы -- ошибка вида при включенной галке парольной аутентификации через керберос
```
>>>KRBError:
         sTime is Mon Oct 07 17:36:33 UTC 2024 1728322593000
         suSec is 644455
         error code is 68
         error Message is null
         sname is krbtgt/FSKEES.RU@FSKEES.RU
         msgType is 30
                [Krb5LoginModule] authentication failed
```

> N.B. логика создания kerberos принципала в кейклоке следующая: при импорте пользователя берется атрибут указанный в поле Kerberos principal attribute и записывается в readOnly атрибут пользователя KERBEROS_PRINCIPAL. При аутентификации значение достается из KERBEROS_PRINCIPAL, и если оно с доменным суффиксом, то отдается в KDC как есть, если без суффикса, то суффикс приделывается исходя из kerberos realm'а. Т.е. если UPN с некорректным суффиксом, а sAMAccountName корректный, то sAMAccountName в Kerberos principal attribute решит проблему. При этом, в версии ниже 22.0.5 зачем-то сделана странная проверка на доменный суффикс, и UPN, если суффикс отличается от реалма даже не будет отправлен в KDC(процесс сразу свалится с ошибкой). С 22.0.5 это поведение убрали, но почему-то sAMAccountName в Kerberos principal attribute ломает импорт пользователей. Кажется, что единственное рабочее -- не заполнять Kerberos principal attribute вообще, в этом случае кейклок положит в KERBEROS_PRINCIPAL username

3. Проверить криптоалгоритмы в krb5.conf. Вероятно надо включить allow_weak_crypto = true и что-то дописать в permitted_enctypes. Симптомы -- ошибка вида 
   ```
   2024-06-06 07:54:31,547 WARN  [org.keycloak.federation.kerberos.impl.SPNEGOAuthenticator] (executor-thread-185) SPNEGO login failed: java.security.PrivilegedActionException: GSSException: Failure unspecified at GSS-API level (Mechanism level: Invalid argument (400) - Cannot find key of appropriate type to decrypt AP-REQ - RC4 with HMAC)
   ```

   в этом случае krb5.conf должен выглядеть как-то так:
   ```ini
   [libdefaults]
   default_realm = EXAMPLE.ORG
   allow_weak_crypto = true
   # permitted_enctypes = rc4-hmac arcfour-hmac arcfour-hmac-md5
   # default_tkt_enctypes = rc4-hmac arcfour-hmac arcfour-hmac-md5
   # default_tgs_enctypes = rc4-hmac arcfour-hmac arcfour-hmac-md5
   default_tkt_enctypes = aes256-cts-hmac-sha1-96 aes128-cts-hmac-sha1-96 rc4-hmac
   default_tgs_enctypes = aes256-cts-hmac-sha1-96 aes128-cts-hmac-sha1-96 rc4-hmac

   [realms]
   EXAMPLE.COM = {
   kdc = DC.EXAMPLE.ORG
   default_domain = EXAMPLE.ORG
   }
   ```

   4. Проверить KVNO. Вероятно у сервис-принципала сменился пароль и кейтаб протух
   5. Если на проде все работает а на тесте не работает SSO(парольный вход через керберос работает), то проверьте, что у теста и прода __РАЗНЫЕ__ SPN! SPNEGO когда запрашивает тикет, он запрашивает его именно на SPN вида HTTP/<url_сервиса>@РЕАЛМ и если у вас тест и прод не на одном домене, а кейтаб от прода вы просто переложили на тест, то тикет от теста продовым кейтабом не расшифруется