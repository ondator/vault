# Аутентификация 2. Службы каталогов и LDAP
> Disclamer: тут мы достаточно поверхностно пройдемся по возможностям каталогов X500 и протоколу LDAP. Остановимся ровно в тот момент, когда сможем уверенно высосать необходимую для аутентификации пользователей инфу в Keycloak. Если вы хотите углубить свои познания, то можно обратиться к официальным [ISO по X50x](https://www.iso.org/standard/80313.html) (тут просят 150 франков за бумажку, если вы рускоговорящий, то можно почитать бесплатно [соответствующий ГОСТ](https://meganorm.ru/Index/18/18632.htm)), а так же ресурсы [ldap.com](https://ldap.com/) (если вы рускоговорящий, то рекомендую еще и [pro-ldap.ru](https://pro-ldap.ru/))
## Службы каталогов
В каждой организации стремятся управлять правами и полномочиями своих сотрудников централизовано по всему ландшафту. Для автоматизации этого процесса придумали много различных IDM систем, но так или иначе под ними всегда лежит некая служба каталогов (Directory Service или просто DS), в которой, как в базе данных, сложены сами пользователи, их права и полномочия и много чего еще. Именно об этой самой службе каталогов мы тут и поговорим.
Обычно DS имеет иерархичную древовидную структуру, похожую на файловую систему, где в корне лежит домен(DC), а под ним лежат элементы-контейнеры, например O(организация) или OU(орг.юнит) и конечные элементы такие как CN(common name).
 Так же, DS связанна с понятием DNS домена (DC), например mydomain.com, т.к. именно домен является корнем иерархии службы каталогов. При этом, у домена могут быть поддомены, например a.mydomain.com и b.mydomain.com. Вместе вся эта конструкция называется деревом. Но и это еще не все! В некоторых DS (например в Microsoft ActiveDirectory и FreeIPA) можно создавать несколько деревьев доменов, в результате чего получится развесистая структура, которую иногда называют доменным лесом.
 На данный момент, существует множество реализаций службы каталогов, самой распространненной из которых является Microsoft ActiveDirectory. Тем не менее, набирают популярность и OpenSource реализации DS, такие как Samba DC, FreeIPA, OpenLDAP, а так же я иногда встречаю менее распространенных вендоров, таких как Novell eDirectory, Communigate LDAP и пр. Мы в наших упражнениях будем пользоваться готовым контейнером с DS на базе OpenLDAP, который можно подобрать [тут](https://github.com/ondator/sandboxes)

Внутри каталога может лежать все что угодно: пользователи, принтеры, рабочие станции, тех. учетки(gMSA) и еще много всего интересного, но мы тут про авторизацию, так что ограничимся пользователями, группами и объектами-контейнерами. Во первых, надо сказать, что любой объект в службе каталогов получает свой уникальный путь в этом каталоге(Distinguished Name или просто DN), который так же является и неким идентификатором, по которому можно наш объект найти. Выглядит это например так: CN=Bob,OU=MF,OU=IT Department,DC=example,DC=org. Во вторых, каждый объект имеет некий класс. Обычно, интересующие нас пользователи имеют класс inetOrgPerson и/или organizationalPerson.
Помимо этого, у каждого пользователя может быть достаточно большой набор различных аттрибутов как стандартных, так и не очень. Вот несколько полезных стандартных аттрибутов

| описание | Аттрибут(OpenLDAP*) | Аттрибут(AD) | пример |
| --- | --- | ---- | ---- |
| полный путь к пользователю в каталоге | entryDN | distinguishedName | CN=Bob,OU=MF,OU=IT Department,DC=example,DC=org |
| полное имя пользователя с доменом | krbPrincipalName** | userPrincipalName | bob@mydomain.com |
| полное имя пользователя без домена | cn | sAMAccountName | bob |
| группы пользователя. Может иметь несколько значений | memberOf*** | memberOf | CN=My Awesome Group,OU=Groups,DC=example,DC=org |
| пользователи в группе. Может иметь несколько значений | memberUid**** | - | Bob |
| Имя пользователя | givenName | givenName | Bob |
| Фамилия пользователя | sn | sn | Smith |
| Информация о том, как обращаться к пользователю. Чаще всего это ФИО | displayName | displayName | Bob Jason Smith |
| Должность пользователя | title | title | Project Manager |
| Почта | Email | mail | bob.smith@example.org |

\* так же валидно для FreeIPA

** вообще не совсем аналогично UserPrincipalName'у и для появления аттрибута в OpenLDAP надо расширить схему

*** вероятно придется поставить расширение memberOf и использовать нестандартные для OpenLDAP groupOfNames вместо традиционных POSIX-групп

**** атрибут группы, а не пользователя. В стандартных для OpenLDAP POSIX-группах членство регистрируется на группе, а не на пользователе

> Помимо этого, в MS AD у пользователя есть extensionAttribute0-15, и у администраторов AD есть славная традиция именно в них пихать важные данные. Так же можно создавать собственные атрибуты (правда удалить их потом не получится)

> Классы, атрибуты и пр. в DS обычно контролируются схемой, которая может быть расширена администратором при должной сноровке (но это, а так же моделирование DIT DS и пр. нюансы администрирования выходят за рамки данного опуса)
## LDAP
Для того, что бы доступиться к этому великолепию используется протокол LDAP. LDAP -- это специальный протокол, который предназначен для того, что бы предоставлять стандартный интерфейс ко всем службам каталогов. На данный момент, как и любой уважающий себя протокол может работать over SSL(LDAPS). LDAP имеет несколько операций для полноценной работы с каталогом, но мы тут про аутентификацию, так что все мы рассматривать не будем. Посмотрим на 2: search и bind

### bind
Bind -- это простейшая операция аутентификации встроенная в LDAP протокол. Имеются 2 опции -- SASL и simple(по логину-паролю). В SASL кейклок не умеет, поэтому дальше мы поговорим именно о simple bind. Если аутентификация прошла успешно, то приходит success результат с кодом 0. Если не успешно, то приходит ошибка, из которых самая интересная - 49 (InvalidCredentials). В случае AD вместе с ней приходят и поясненительные коды в поле data, например 52e (пользователь с нужным DN есть, но пароль не верный). На самом деле, LDAP simple bind очень небезопасный, хотя бы потому, что без SSL (LDAP без S) он передает логины-пароли в открытом виде и их можно угнать даже левой пяткой. 
> если хотите преисполниться еще, то [вот](https://habr.com/ru/companies/avanpost/articles/484186/) целая статья про то, почему никогда не надо использовать LDAP bind даже для аутентификации внутри КСПД(intranet). 
 
Тем не менее, для всех сторонних систем аутентификации использующих DS как своеобразную базу данных по управлению пользователями и полномочиями, LDAP bind -- необходимое зло. В этом случае, рекомендуется вооружиться хорошими файрволами и организовать доступ до LDAP только той системе, которой он действительно необходим или использовать SASL вместо simple bind, а для всех остальных, мы чуть дальше поговорим о Kerberos.

> Вот тут вот есть отличная [картинка про пентестинг ActiveDirectory](https://orange-cyberdefense.github.io/ocd-mindmaps/img/pentest_ad_dark_2022_11.svg) (требуется zoom out что бы не искать начало). Обратите внимание, что первым делом хакеры пытаются просеять базу пользователей через ldapsearch -x, поэтому точно не стоит торчать LDAP'ом в интернет и вероятно даже внутри корп. сети лучше включить SASL(хотя я ни разу не видел, что бы кто-то это делал, но и, с другой стороны, ни разу не видел что бы LDAP торчал в интернет)

### Search
Search - операция для поиска в DS. Что бы что-то поискать search'ем нужно, как минимум, передать 
- фильтр для поиска в специальном формате 
- базовый DN с которого начинать поиск 
- scope, который говорит искать ли только на текущем уровне(base), только на детях указанного DN(one) или рекурсивно пройти все поддерево(sub)
- и набор атрибутов, которые мы хотим видеть у результата

Что бы поэксперементировать с search есть даже специальная утилита ldapsearch, которой можно потыкать в DS, например так
```bash
ldapsearch -D "cn=my-account,dc=example,dc=org" -b "dc=example,dc=org" -s sub "(&(objectclass=inetOrgPerson)(objectclass=organizationalPerson))" uid, mail, sn, givenName
```
Таким образом, мы авторизуемся в каталоге под учеткой с dn "cn=my-account,dc=example,dc=org" и пытаемся подобрать, рекурсивно спускаясь по поддереву "dc=example,dc=org", все записи в которых класс и inetOrgPerson и organizationalPerson, при этом у этих записей мы хотим получить атрибуты uid, mail, sn и givenName
> в LDAP search поддерживает паджинацию, в этом случае DS вернет результат + метки для листания. К сожалению, не все DS это поддерживают
## Настройка Keycloak

Для начала, определимся чего мы хотим: мы хотим, что бы пользователи из каталога могли аутентифицироваться через кейклок по доменному логину и паролю. Т.е. примерно так:

```puml
actor User as c
participant Keycloak as k
participant LDAP as l

c ->  k: отправляем доменные логин и пароль
k -> l: делаем LDAP bind с этими данными
l -->  k: результат аутентификации
k --> c: сообщаем пользователю результат
```

> рекомендую немедленно попрактиковаться с настройкой используя тестовую песочницу, которую можно скачать [тут](https://github.com/ondator/sandboxes). Вам нужен компоуз `keycloak/keycloak-postgres-dc.yml`

Что бы настроить интеграцию с LDAP в Keycloak необходимо создать новую сущность User Federation. Создается оно на соответствующей вкладке, где мы создаем нового провайдера типа LDAP. Перед нами отроется окно с кучей инпутов, которые мы должны заполнить:
+ UI display name -- просто название, ни на что не влияет
+ Vendor -- достаточно важный селектор, который заставляет кейклок выбрать специфичные для вендора аттрибуты записей каталога. Например, для MS AD будет вытащен . Т.о. если ваш вендор службы каталога есть в списке, то настоятельно рекомендую выбрать именно его, в случае FreeIPA, Samba и OpenLDAP (наш случай) я выбираю "Other".
+ Connection URL -- сюда пишем путь до сервера LDAP вместе с протоколом. В нашем случае это ldap://ldap
+ Enable StartTLS -- эта галка заставит LDAP-сервер принудительно перейти с незащищенного ldap на защищенный ldaps. Сработает только, если сервер это поддерживает + придется заранее добавить сертификат в доверенные кейклока (об этом ниже). В наших экспериментах галочку оставим отключенной
+ Use Truststore SPI -- эта штука фактически определяет откуда брать доверенные SSL сертификаты. Если выбираем Always, то можно будет передавать путь к сертам в переменных окружения. Если Never, то будет использован только стандартный джавовый кейстор. Мы идем по нешифрованной дорожке, поэтому нам тут не принципиально
+ Connection pooling -- будет создан и использован пул LDAP-соединений. В этом нет необходимости, если вы не планируете инфу о пользователях читать всегда напрямую из LDAP. В нашем случае включать не будем
+ Connection timeout -- таймаут на соединение с LDAP сервером. Обратите внимание, что это именно таймаут на **соединение**. Таймаут на чтение выставляется ниже.
+ Bind type -- тут только 2 опции simple (simple bind) и none(анонимный доступ). SASL даже не предлагают. Из 2х зол мы выбираем simple
+ Bind DN и Bind credentials -- вводим кредентали для подключения. Обратите внимание, что в Bind DN вводим именно DN, а не username/cn/sAMAccountName. В нашем случае это пара cn=keycloak2,ou=tuz,dc=example,dc=org / password
> Тут очень рекомендую остановиться и последовательно прожать 2 кнопки Test connection и Test authentication. Если все хорошо, то вы должны увидеть 2 зеленых попапа
![alt text](/assets/img/ldap.png)

Идем дальше, в секцию LDAP searching and updating 
+ Edit mode -- тут 3 варианта: 
  - READONLY -- наиболее распространенный вариант, пользователи будут высосаны из LDAP и сохранены без обратной синхронизации, но и в Keycloak они будут readonly. 
  - WRITABLE -- пользователи будут синхронизироваться в 2 стороны. Вероятно полезно, если Keycloak используется не как IAM система(управление доступом), но и как IDM(управление пользователями, правами и полномочиями). Использовать стоит на свой страх и риск
  - UNSYNCED -- этот режим похож на READONLY, но с тем отличием, что пользователей можно менять в кейклоке. Обычно полезно если хотите странного, например менять атрибуты пришедшие из LDAP
+ Users DN -- базовый контейнер из которого будут забраны пользователи. Проще всего вписать сюда корневой контейнер-домен, но обычно стоит попросить более высокий по иерархии контейнер с пользователями. У нас это будет ou=people,dc=example,dc=org
+ Username LDAP attribute -- какой атрибут будет использоваться в качестве username в keycloak. Для MS AD это чаще всего UserPrincipalName, для остальных cn. Иногда, для особо кривых инсталяций AD еще приходится использовать sAMAccountName. Значение этого поля будет прошито в дуальном маппере на username (про мапперы поговорим позже)
+ RDN LDAP attribute -- некий уникальный атрибут, по которому можно отличить одного пользователя от другого. Как правило это cn или uid (в AD всегда cn). В нашем случае можно брать любой, я выбрал uid
+ UUID LDAP attribute -- служебный ID-атрибут записи в каталоге. В MS AD это objectGUID, в остальных обычно entryUUID
+ User object classes -- классы, которые будем забирать из LDAP-каталога. Обычно это inetOrgPerson, organizationalPerson, но лучше уточнить у админа каталога
+ User LDAP filter -- вероятно вам нужны не все пользователи, а, например, пользователи входящие в определенную группу. В этом случае, здесь можно прописать некий ldap-фильтр. В нашем случае, оставляем пустым (или можете поиграться)
+ Search scope -- указываем scope поиска, как обсуждали выше. Варианты OneLevel (высасываем только текущий уровень), Subtree (достаем все поддерево рекурсивно). Почти всегда используется Subtree
+ Read timeout -- вот это вот таймаут на чтение. Если LDAP-сервер не вернет ответ за указанное время, то синхронизацию отобъет по таймауту. Мы выставлять не будем
+ Pagination -- включает возможность паджинции. К сожалению не все сервера ее поддерживают, а некоторые еще и ломаются, если ее включить. Мы выключим
+ Import users -- важная галка. Если мы ее выключаем, то пользователи **не будут** импортированы в кейклок разом, а это будет происходить on-demand, когда конкретный пользователь придет аутентифицироваться. Если пользователи вам нужны в кейлоке (например вы что-то хотите делать с ними через API), то галку выключать не надо. Мы так же выключать не будем
+ Sync Registrations -- вообще кейлок поддерживает самостоятельную регистрацию пользователей. Т.е. если тебя нет в системе, то пойди, зарегестрируйся и вуаля. Если мы включим эту галку, то зарегестрированный пользователь уедет еще и в LDAP. Я эту галку всегда выключал и вам тоже советую
+ Batch size -- размер пакета, если включена паджинация
+ Periodic full sync и Full sync period -- включение и интервал периодической полной загрузки пользователей. Если включаем, то пользователи периодически будут полностью перезагружаться из LDAP-каталога. Я включаю с таймаутом раз в сутки
+ Periodic changed users sync и Changed users sync period -- то же самое, но для дельты. Обычно выставляю раз в 4 часа

Настройки Kerberos мы рассмотрим в следующей части, настройки кеширования мне никогда не приходилось менять с дефолтных, остается посмотреть на Advanced settings
+ Enable the LDAPv3 password modify extended operation -- эта штука позволяет использовать внешний сброс пароля пользователя, используя для этого фичу ["LDAP Password Modify Extended Operation"](https://www.rfc-editor.org/rfc/rfc3062.html). Что бы это стало востребованным, надо, как минимум, включить галочку Sync Registrations, что вряд-ли когда-то случится (я ни разу не включал)
+ Validate password policy -- Keycloak поддерживает настройку парольных политик (пароль должен содержать 5 цифр, заглавные буквы, спецсимвол, нос утконоса, кровь единорога и должен меняться каждую наносекунду). Если включить эту галку, то кейклок будет проверять пароли на соответствие. Причем он будет проверять на соответствие некоторым политикам даже пароли, которые хранятся в DS. Обычно пароли все-таки хранятся в DS и политики выставляются и контролируются там же, поэтому галка выключается
+ Trust Email -- Это значит, что пользователь появится в keycloak сразу с "подтвержденным" email'ом. Эту галку обычно стоит включить, что бы все пользователи не появлялись с назойливыми аллертами про неподтвержденный имейл

Заполнив все поля, жмем кнопку Save

После того как мы все настроили, можно попробовать вытащить наших пользователей в keycloak (разумеется, если у нас включен Import users). Для этого вверху экрана, рядом с галкой Disabled находится меню Action с несколькими опциями
![alt text](/assets/img/ldap-menu.png)


+ Sync changed users -- синхронизирует дельту по пользователям со службой каталогов
+ Sync all users -- синхронизирует всех пользователей со службой каталогов
+ Unlink users -- у пользователей пропадает связь с федерацией (службой каталогов) и они становятся как бы локальными. При этом, все атрибуты сохраняются. Важно: эта операция строго односторонняя и восстановить связь обратно без специальной магии (не влезая руками в базу кейклока) невозможно. Пользуйтесь аккуратно
+ Remove imported -- удаляет пользователей затянутых через эту федерацию из кейклока
+ Delete provider? -- удаляет федерацию

Если мы сейчас запустим Sync all users, то, по прошествии какого-то времени, в разделе Users должны появиться новые пользователи. Обратите внимание, что у новых пользователей есть связь с федерацией Federation link

![alt text](/assets/img/ldap-user.png)

> Важно понимать, что пользователь, который приехал из федерации кардинально отличается от локального пользователя, которого вы руками создадите в keycloak. В частности, большая часть атрибутов такого пользователя контролируется федерацией, часть атрибутов может быть readonly, а еще часть вообще появляться on-demand (в разделе про мапперы подробнее поговорим про галку Always read for LDAP)
> Так же важно понимать, что такой "федерированный" пользователь может иметь только одну связь с федерацией. Не может быть пользователей связанных с 2мя и более LDAP-каталогами 

Теперь мы можем попробовать выйти из keycloak и зайти под доменной учетной записью. Попробуйте, например, зайти под alice:password. Если мы попали в кейклоак, но с ошибкой "No realm access", то это успех (просто у alice не хватает прав на доступ к админке)

### Сертификаты
Если у вас по какой-то причине версия Keycloak ниже 18 и нет возможности обновиться, то все плохо и можно только насильственно засунуть сертификат в джавовый кейстор. Получится что-то типа
```
keytool -importcert -alias ldapcert -cacerts -noprompt -trustcacerts -file /opt/jboss/keycloak/standalone/configuration/ldap.cer
```

Если у вас новый кейклок, то можно воспользоваться уже упомянутым выше Truststore SPI. Просто указываем нужный нам серт в переменных и вуаля: 
    KEYCLOAK_HTTPS_KEY_STORE_FILE: /path/to/truststore.jks
 и KEYCLOAK_HTTPS_KEY_STORE_PASSWORD: .....
> Если у вас образы от quai.io, то переменные KC_HTTPS_KEY_STORE_FILE и KC_HTTPS_KEY_STORE_PASSWORD, соответственно

Не забудьте выставить Use Truststore SPI в Always
### Мапперы
Каждый пользователь, прогруженный кейклоком из LDAP-каталога, имеет ряд атрибутов таких как Firstname, Lastname, Email и др. Откуда же берется информация для заполнения этих атрибутов и как keycloak понимает какие данные писать в какие атрибуты? И что делать если мне нужно как-то расширить пользователя, добавив ему новый атрибут? Все это можно сделать используя мапперы. 
Для начала перейдем в нашу новую федерацию и переключимся на вкладку Mappers. Тут мы видим список мапперов, которые keycloak любезно сделал для нас со стандартными данными. Давайте попробуем создать новый маппер. Жмем кнопку "Add mapper" и заполняем название и тип маппера. Тип маппера -- это крайне важный селектор, от которого зависит все остальное. Все возможные типы мапперов приводить не буду, вот наиболее полезные:
+ user-attribute-ldap-mapper -- записывает атрибут, полученный из LDAP в атрибут пользователя. Наиболее распространенный тип.
+ hardcoded-attribute-mapper -- записывает некое значение (всегда одно и то же) в атрибут каждого пользователя
+ hardcoded-ldap-role-mapper -- включает каждого пользователя в выбранную роль
> У MS AD есть специфичный маппер msad-user-account-control-mapper, который контролирует, среди прочего, "включенность" пользователя через отлов специальных кодов ошибок 553 и 775. В остальных реализациях DS "активность" пользователей не контролируется.

Дальше посмотрим на user-attribute-ldap-mapper, как на наиболее часто используемый, да и полей у него больше всего:
+ User Model Attribute -- это тот атрибут в который будет записано значение взятое из LDAP-каталога. Обратите внимание, что у пользователя есть ряд стандартных атрибутов (username, firstName, lastName, email), но никто не мешает завести свои
+ LDAP Attribute -- атрибут пользователя в LDAP-каталоге, значение которого будем мапить в атрибут пользователя в кейклоке
+ Read Only -- эта галка проявляет себя если у нас в федерации Edit mode выставлен в WRITABLE, т.е. синхронизация идет не только из LDAP в keycloak, но и обратно. Так вот, Read Only флаг говорит кейклоку, что синхронизировать значение атрибута обратно в LDAP не нужно
+ Always Read Value From LDAP -- опасная галка с говорящим названием. Помеченный этим флагом атрибут будет всегда читаться из LDAP, а не из keycloak. Выставляя ее, надо поинмать, что во-первых, теперь при попытке доступиться до пользователя всегда будет выполняться LDAP-запрос, а во-вторых, локально в кейклоке этого атрибута может не быть впринципе (т.к. кейклок всегда может его прочитать напрямую с LDAP, то и сохранять локально он его будет постольку-поскольку). Так же, обратите внимание, что часть стандартных кейклоковских мапперов имеют этот флаг
+ Is Mandatory In LDAP -- тоже опасная галка, потому что название не соответствует действительности. На самом деле, эта штука не будет взрываться при отсутствии атрибута в LDAP, а всего лишь будет выставлять дефолтное значение
+ Attribute default value и Force a Default Value -- как раз и определяют то самое дефолтное значение. Если дефолтное значение указано и выставлено Force a Default Value, то берется оно. Если не выставлено или не указано, то берется " "(пробел). Обратите внимание, что что бы применился указанный дефолт, надо **и** выставить галку **и** заполнить поле
+ Is Binary Attribute -- внезапно, в атрибутах могут быть какие-то бинарные данные, например картинки или даже документы. Я, например, видел примеры, когда сертификаты ЭЦП в формате X509 клали в LDAP-атрибут пользователя. Вот это вот как раз галочка на этот случай. Если нам нужно забрать данные пользователя и они бинарные, то их необходимо пометить этой галкой (иначе кейклок может сломаться). Так же, важно понимать, что эта галка автоматически подразумевает, что атрибут будет читаться из LDAP и локально в базе храниться не будет никогда.

Если заполнить поля, сохранить маппер и еще раз запустить синхронизацию пользователей, то у всех в профиле появится соответствующий атрибут

### Дебаг
- LDAP стандартно использует для связи с LDAP-сервером порт 389. Если используется LDAPS(LDAP over SSL), то порт меняется на 636. Первым делом, проверьте, что порты открыты. Проверить можно просто сделав курл вида `curl -k ldap://ldap`
- Можно заставить Keycloak писать расширенные логи по LDAP. Для этого надо в контейнерах от bitnami выставить env'ы 
```
KEYCLOAK_LOG_LEVEL: WARN,...,,org.keycloak.storage.ldap:trace
```
> в контейнерах от quay.io все то же самое, но енв называются KC_LOG_LEVEL. Если запускаем jar, то настраиваем в standalone-ha.xml, согласно документации

- Если видим ошибку вида SSLHandshakeException, то, скорее всего нам надо добавить сертификат в доверенные по инструкции выше
- Если не проходит LDAP bind и вы интегрируетесь с MS AD, то вам помимо ошибки придет еще и код в поле data, по которому можно понять что пошло не так. Вот несколько наиболее распространенных:
    - 52e -- логин верный, а пароль нет
    - 533 -- пользователь выключен
    - 775 -- пользователь заблокирован
    - 532 и 773 -- пароль протух